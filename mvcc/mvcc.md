
## mvcc 多版本实现快照隔离
[参考](https://github.com/Vonng/ddia/blob/master/ch7.md)

实现快照隔离:

与读取提交的隔离类似，快照隔离的实现通常使用写锁来防止脏写.
这意味着进行写入的事务会阻止另一个事务修改同一个对象。
但是读取不需要任何锁定。从性能的角度来看，快照隔离的一个关键原则是：读不阻塞写，写不阻塞读

这允许数据库在处理一致性快照上的长时间查询时，可以正常地同时处理写入操作。且两者间没有任何锁定争用。

如果一个数据库只需要提供读已提交的隔离级别，而不提供快照隔离，
那么保留一个对象的两个版本就足够了：提交的版本和被覆盖但尚未提交的版本。
支持快照隔离的存储引擎通常也使用MVCC来实现读已提交隔离级别。
一种典型的方法是读已提交为每个查询使用单独的快照，而快照隔离对整个事务使用相同的快照。

![](https://oscimg.oschina.net/oscnet/up-459951ef8d5d58615a33ac70606c64b0193.png)

事务13 从账户2 中扣除100美元，将余额从500美元改为400美元。实际上包含两条账户2 的记录：余额为 $500 的行被标记为被事务13删除，余额为 $400 的行由事务13创建。



### 观察一致性快照的可见性规则

当一个事务从数据库中读取时，事务ID用于决定它可以看见哪些对象，看不见哪些对象.

1.在每次事务开始时，数据库列出当时所有其他（尚未提交或尚未中止）的事务清单，即使之后提交了，这些事务已执行的任何写入也都会被忽略。
2.被中止事务所执行的任何写入都将被忽略。
3.由具有较晚事务ID（即，在当前事务开始之后开始的）的事务所做的任何写入都被忽略，而不管这些事务是否已经提交。
4.所有其他写入，对应用都是可见的